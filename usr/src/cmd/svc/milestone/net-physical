#!/sbin/sh
#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#
#
# Copyright (c) 1999, 2010, Oracle and/or its affiliates. All rights reserved.
# Copyright 2012 Milan Jurik. All rights reserved.
# Copyright (c) 2013 by Delphix. All rights reserved.
#
# Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T.
# All rights reserved.
#

. /lib/svc/share/smf_include.sh
. /lib/svc/share/net_include.sh

#
# In a shared-IP zone we need this service to be up, but all of the work
# it tries to do is irrelevant (and will actually lead to the service
# failing if we try to do it), so just bail out.
# In the global zone and exclusive-IP zones we proceed.
#
smf_configure_ip || exit $SMF_EXIT_OK

smf_netstrategy

#
# The network initialization is done early to support diskless and
# dataless configurations.  For IPv4 interfaces that were configured by
# the kernel (e.g.  those on diskless machines) and not configured by
# DHCP, reset the netmask using the local "/etc/netmasks" file if one
# exists, and then reset the broadcast address based on the netmask.
#
/sbin/ifconfig -auD4 netmask + broadcast +

#
# Enable interfaces set up with ipadm.
#
/sbin/ipadm show-if -p -o ifname,state,current | \
    while IFS=: read intf state current; do
	if  [[ "$state" != "disabled" && $current != *Z* ]]; then
		#
		# skip if not a persistent interface, or if it should get IP
		# configuration from the global zone ('Z' flag is set)
		#
		continue;
	elif is_iptun $intf; then
		# skip IP tunnel interfaces enabled by net-iptun
		continue;
	elif [[ -f /etc/hostname.$intf || -f /etc/hostname6.$intf || \
	    -f /etc/dhcp.$intf ]]; then
		#
		# There is conflicting ipadm and /etc/hostname* legacy
		# configuration for this interface.  There is no way to guess
		# the intent of the administrator, so go into maintenance mode
		# and let the administrator sort this out.
		#
		echo "Stray legacy network configuration found for $intf"
		exit $SMF_EXIT_ERR_FATAL
	fi

	if ! /sbin/ipadm enable-if -t $intf; then
		intf_failed="$intf_failed $intf"
	fi
done

if [[ -n "$intf_failed" ]]; then
	warn_failed_ifs "enable" "$intf_failed"
fi

#
# Plumb IPMP interfaces.  We handle these separately as their configuration
# is not in ipadm yet.
#
inet_names=`get_interface_names /etc/hostname`
inet6_names=`get_interface_names /etc/hostname6`
for ifname in $inet_names; do
	if is_ipmp $ifname inet && ! if_configure $ifname inet ipmp; then
		ipmp_failed="$ipmp_failed $ifname"
	fi
done
[ -n "$ipmp_failed" ] && warn_failed_ifs "configure IPv4 IPMP" "$ipmp_failed"

for ifname in $inet6_names; do
	if is_ipmp $ifname inet6 && ! if_configure $ifname inet6 ipmp; then
		ipmp6_failed="$ipmp6_failed $intf_name"
	fi
done
[ -n "$ipmp6_failed" ] && warn_failed_ifs "configure IPv6 IPMP" "$ipmp6_failed"

#
# Now plumb IPMP underlying interfaces
#
for ifname in $inet_names; do
	if is_ipmp_under $ifname inet && ! if_configure $ifname inet; then
		under_failed="$under_failed $ifname"
	fi
done
[ -n "$under_failed" ] && warn_failed_ifs "configure IPv4" "$under_failed"

for ifname in $inet6_names; do
	if is_ipmp_under $ifname inet6 && ! if_configure $ifname inet6; then
		under6_failed="$under6_failed $ifname"
	fi
done
[ -n "$under6_failed" ] && warn_failed_ifs "configure IPv6" "$under6_failed"

#
# In order to avoid bringing up the interfaces that have
# intentionally been left down, perform RARP only if the system
# has no configured hostname in /etc/nodename
#
hostname="`shcat /etc/nodename 2>/dev/null`"
if [ "$_INIT_NET_STRATEGY" = "rarp" -o -z "$hostname" ]; then
	/sbin/ifconfig -adD4 auto-revarp netmask + broadcast + up
fi

#
# If the /etc/defaultrouter file exists, process it now so that the next
# stage of booting will have access to NFS.
#
if [ -f /etc/defaultrouter ]; then
	while read router rubbish; do
		case "$router" in
			'#'* | '') ;;	#  Ignore comments, empty lines
			*)	/sbin/route -n add default -gateway $router ;;
		esac
	done </etc/defaultrouter
fi

#
# If we get here and were not asked to plumb any IPv4 interfaces, look
# for boot properties that direct us.
#
# - The "network-interface" property is required and indicates the
#   interface name.
# - The "xpv-hcp" property, if present, is used by the hypervisor
#   tools to indicate how the specified interface should be configured.
#   Permitted values are "dhcp" and "off", where "off" indicates static
#   IP configuration.
#
# In the case where "xpv-hcp" is set to "dhcp", no further properties
# are required or examined.
#
# In the case where "xpv-hcp" is not present or set to "off", the
# "host-ip" and "subnet-mask" properties are used to configure
# the specified interface.  The "router-ip" property, if present,
# is used to add a default route.
#
nic="`/sbin/devprop network-interface`"
if smf_is_globalzone && [ -z "$inet_list" ] && [ -n "$nic" ]; then
	hcp="`/sbin/devprop xpv-hcp`"
	case "$hcp" in
	"dhcp")
		/sbin/ifconfig $nic plumb 2>/dev/null
		[ -n "`/sbin/ifconfig $nic 2>/dev/null`" ] && (
			# The interface is successfully plumbed, so
			# modify "inet_list" to force the exit code
			# checks to work.
			inet_list=$nic;
			# Given that this is the only IPv4 interface,
			# we assert that it is primary.
			echo "starting DHCP on primary interface $primary";
			/sbin/ifconfig $nic auto-dhcp primary;
			# Exit code 4 means ifconfig timed out waiting
			# for dhcpagent
			[ $? != 0 ] && [ $? != 4 ] && \
			    i4d_fail="$i4d_fail $nic";
		)
		;;

	"off"|"")
		/sbin/devprop host-ip subnet-mask router-ip | (
			read ip;
			read mask;
			read router;
			[ -n "$ip" ] && [ -n "$mask" ] && \
				/sbin/ifconfig $nic plumb 2>/dev/null
			[ -n "`/sbin/ifconfig $nic 2>/dev/null`" ] && (
				# The interface is successfully
				# plumbed, so modify "inet_list" to
				# force the exit code checks to work.
				inet_list=$nic;
				/sbin/ifconfig $nic  inet $ip \
				    netmask $mask broadcast + up 2>/dev/null;
				[ -n "$router" ] && route add \
				    default $router 2>/dev/null;
			)
		)
		;;
	esac
fi

#
# We now wait a few seconds to allow asynchronous configuration events such as
# DHCP lease acquisition and duplicate address detection to complete.
#
i=0
while [[ $i -lt 5 ]]; do
	done=true

	/sbin/ipadm show-addr -p -o type,state,addr | \
	    while IFS=: read type state addr; do
		#
		# DHCP addresses with lease acquisition pending have an addr
		# field of "?", and addresses with ongoing DAD have a state
		# of "tentative".
		#
		[[ $type == dhcp && $addr == ? || $state == tentative ]] && \
		    done=false
	done

	# Exit if there are no addresses to wait for
	$done && exit $SMF_EXIT_OK

	i=`expr $i + 1`
	sleep 1
done

exit $SMF_EXIT_OK
