.\" The contents of this file are subject to the terms of the Common
.\" Development and Distribution License (the "License").  You may not use
.\" this file except in compliance with the License.
.\"
.\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or
.\" http://www.opensolaris.org/os/licensing.  See the License for the
.\" specific language governing permissions and limitations under the
.\" License.
.\"
.\" When distributing Covered Code, include this CDDL HEADER in each file
.\" and include the License file at usr/src/OPENSOLARIS.LICENSE.  If
.\" applicable, add the following below this CDDL HEADER, with the fields
.\" enclosed by brackets "[]" replaced with your own identifying
.\" information: Portions Copyright [yyyy] [name of copyright owner]
.\"
.\" Copyright (c) 2002, Sun Microsystems, Inc.  All Rights Reserved
.\" Copyright 2022 OmniOS Community Edition (OmniOSce) Association.
.\"
.Dd March 7, 2022
.Dt RBAC 7
.Os
.Sh NAME
.Nm rbac ,
.Nm RBAC
.Nd role-based access control
.Sh DESCRIPTION
The addition of role-based access control
.Pq RBAC
to the illumos operating environment gives developers the opportunity to
deliver fine-grained security in new and modified applications.
RBAC is an alternative to the all-or-nothing security model of traditional
superuser-based systems.
With RBAC, an administrator can assign privileged functions to specific user
accounts
.Pq or special accounts called roles .
.Pp
There are two ways to give applications privileges:
.Bl -enum -offset Ds
.It
Administrators can assign special attributes such as setUID to application
binaries
.Pq executable files .
.It
Administrators can assign special attributes such as setUID to applications
using execution profiles.
.El
.Pp
Special attribute assignment along with the theory behind RBAC is discussed in
detail in
.Em Role Based Access Control
chapter of the
.%T System Administration Guide: Security Services .
This chapter describes what authorizations are and how to code for them.
.Ss Authorizations
An authorization is a unique string that represents a user's right to perform
some operation or class of operations.
Authorization definitions are stored in a database called
.Xr auth_attr 5 .
For programming authorization checks, only the authorization name is
significant.
.Pp
Some typical values in an
.Xr auth_attr 5
database are shown below.
.Bd -literal -offset 4n
solaris.jobs.:::Cron and At Jobs::help=JobHeader.html
solaris.jobs.grant:::\e
    Delegate Cron & At Administration::help=JobsGrant.html
solaris.jobs.admin:::Manage All Jobs::help=AuthJobsAdmin.html
solaris.jobs.user:::Cron & At User::help=JobsUser.html
.Ed
.Pp
Authorization name strings ending with the
.Sy grant
suffix are special authorizations that give a user the ability to delegate
authorizations with the same prefix and functional area to other users.
.Ss Creating Authorization Checks
To check authorizations, use the
.Xr chkauthattr 3SECDB
or
.Xr chkauthattr_ucred 3SECDB
library functions, which verify whether or not a user has a given
authorization.
.Fn chkauthattr
and
.Fn chkauthattr_ucred
check the
.Xr policy.conf 5 ,
.Xr user_attr 5 ,
and
.Xr prof_attr 5
databases in order for a match to the given authorization.
Authorisations which are granted via a profile which is assigned to the user's
authenticated profile list, will only be satisfied if the current process UID
is the same as the requested user's UID, and that process has the
.Dv PRIV_PFEXEC_AUTH
process flag, such as assigned by
.Xr pfexec 1 .
For
.Fn chkauthattr_ucred ,
the provided
.Vt ucred
is checked for this flag instead, allowing servers to check whether a
connecting client has access to the authenticated profiles.
.Pp
If you are modifying existing code that tests for root UID, you should find the
test in the code and replace it with the
.Fn chkauthattr
function.
A typical root UID check is shown in the first code segment below.
An authorization check replacing it is shown in the second code segment; it
uses the solaris.jobs.admin authorization and a variable called
.Va real_login
representing the user.
.Sy Example 1 No Standard root check
.Bd -literal -offset 4n
ruid = getuid();

if ((eflag || lflag || rflag) && argc == 1) {
	if ((pwp = getpwnam(*argv)) == NULL)
		crabort(INVALIDUSER);

	if (ruid != 0) {
		if (pwp->pw_uid != ruid)
			crabort(NOTROOT);
		else
			pp = getuser(ruid);
	} else
		pp = *argv++;
} else {
.Ed
.Pp
.Sy Example 2 No Authorization check
.Bd -literal -offset 4n
 ruid = getuid();
 if ((pwp = getpwuid(ruid)) == NULL)
	 crabort(INVALIDUSER);

 strcpy(real_login, pwp->pw_name);

 if ((eflag || lflag || rflag) && argc == 1) {
	 if ((pwp = getpwnam(*argv)) == NULL)
		 crabort(INVALIDUSER);

	 if (!chkauthattr("solaris.jobs.admin", real_login)) {
		 if (pwp->pw_uid != ruid)
			 crabort(NOTROOT);
		 else
			 pp = getuser(ruid);
	 } else
		 pp = *argv++;
 } else {
.Ed
.Pp
For new applications, find an appropriate location for the test and use
.Fn chkauthattr
as shown above.
Typically the authorization check makes an access decision based on the
identity of the calling user to determine if a privileged action
.Pq for example, a system call
should be taken on behalf of that user.
.Pp
Applications that perform a test to restrict who can perform their
security-relevant functionality are generally
.Sy setuid
to root.
Programs that were written prior to RBAC and that are only available to the
root user may not have such checks.
In most cases, the kernel requires an effective user
.Sy ID
of root to override policy enforcement.
Therefore, authorization checking is most useful in programs that are
.Sy setuid
to root.
.Pp
For instance, if you want to write a program that allows authorized users to
set the system date, the command must be run with an effective user
.Sy ID
of root.
Typically, this means that the file modes for the file would be -rwsr-xr-x with
root ownership.
.Pp
Use caution, though, when making programs
.Sy setuid
to root.
For example, the effective
.Sy UID
should be set to the real
.Sy UID
as early as possible in the program's initialization function.
The effective
.Sy UID
can then be set back to root after the authorization check is performed and
before the system call is made.
On return from the system call, the effective UID should be set back to the real
.Sy UID
again to adhere to the principle of least privilege.
.Pp
Another consideration is that
.Ev LD_LIBRARY
path is ignored for setuid programs
.Po
see SECURITY section in
.Xr ld.so.1 1
.Pc
and that shell scripts must be modified to work properly when the effective and
real
.Sy UID Ns No s
are different.
For example, the
.Fl p
flag in Bourne shell is required to avoid resetting the effective
.Sy UID
back to the real
.Sy UID .
.Pp
Using an effective
.Sy UID
of root instead of the real
.Sy UID
requires extra care when writing shell scripts.
For example, many shell scripts check to see if the user is root before
executing their functionality.
With RBAC, these shell scripts may be running with the effective
.Sy UID
of root and with a real
.Sy UID
of a user or role.
Thus, the shell script should check
.Sy euid
instead of
.Sy uid .
For example,
.Bd -literal -offset 4n
WHO=`id | cut -f1 -d" "`
if [ ! "$WHO" = "uid=0(root)" ]; then
    echo "$PROG: ERROR: you must be super-user to run this script.
    exit 1
fi
.Ed
.Pp
should be changed to
.Bd -literal -offset 4n
WHO=`/usr/xpg4/bin/id -n -u`
if [ ! "$WHO" = "root" ]; then
    echo "$PROG: ERROR: you are not authorized to run this script."
    exit 1
fi
.Ed
.Pp
Authorizations can be explicitly checked in shell scripts by checking the
output of the
.Xr auths 1
utility.
For example,
.Bd -literal -offset 4n
for auth in `auths | tr , " "` NOTFOUND; do
    [ "$auth" = "solaris.date" ] && break  # authorization found
done

if [ "$auth" != "solaris.date" ]; then
    echo >&2 "$PROG: ERROR: you are not authorized to set the date"
    exit 1
fi
.Ed
.Sh SEE ALSO
.Xr ld.so.1 1 ,
.Xr pfexec 1 ,
.Xr chkauthattr 3SECDB ,
.Xr auth_attr 5 ,
.Xr policy.conf 5 ,
.Xr prof_attr 5 ,
.Xr user_attr 5
.Rs
.%B System Administration Guide: Security Services
.Re
