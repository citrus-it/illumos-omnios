#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#

#
# Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#
# Copyright (c) 2012, 2017 by Delphix. All rights reserved.
#

STF_PASS=0
STF_FAIL=1
STF_UNRESOLVED=2
STF_NOTINUSE=3
STF_UNSUPPORTED=4
STF_UNTESTED=5
STF_UNINITIATED=6
STF_NORESULT=7
STF_WARNING=8
STF_TIMED_OUT=9
STF_OTHER=10

# Output a comment
#
# $@ - comment text

function log_note
{
	echo "NOTE: $@"
}

# Execute a positive test and exit $STF_FAIL is test fails
#
# $@ - command to execute

function log_must
{
	log_pos "$@"
	(( $? != 0 )) && log_fail
}

# Execute a negative test and exit $STF_FAIL if test passes
#
# $@ - command to execute

function log_mustnot
{
	log_neg "$@"
	(( $? != 0 )) && log_fail
}

# Execute a negative test with keyword expected, and exit
# $STF_FAIL if test passes
#
# $1 - keyword expected
# $2-$@ - command to execute

function log_mustnot_expect
{
	typeset tmp_out=$(mktemp)
	typeset tmp_err=$(mktemp)
	typeset key=$1
	shift

	echo "Running: \"$@\""
	"$@" >$tmp_out 2>$tmp_err
	typeset ret=$?

	if [[ -s $tmp_out ]]; then
		echo "stdout:"
		cat $tmp_out
	fi

	if [[ -s $tmp_err ]]; then
		echo "stderr:"
		cat $tmp_err
	fi

	[[ $ret -eq 0 ]] && echo "ERROR: \"$@\" unexpectedly exited $status"

	if ! grep -q "$key" $tmp_err; then
		echo "ERROR: \"$key\" not found in command stderr"
		ret=0
	fi

	rm -f $tmp_out $tmp_err
	[[ $ret -eq 0 ]] && log_fail
}

# Execute and print command with status where success equals non-zero result
#
# $@ - command to execute
#
# return 0 if command fails, return 1 otherwise

function log_neg
{
	echo "Running: \"$@\""
	"$@"
	typeset status=$?

	[[ $status -eq 0 ]] && echo "ERROR: \"$@\" unexpectedly exited $status"
	return $(($status == 0))
}

# Execute and print command with status where success equals zero result
#
# $@ command to execute
#
# return command exit status

function log_pos
{
	echo "Running: \"$@\""
	"$@"
	typeset status=$?
	[[ $? -ne 0 ]] && echo "ERROR: \"$@\" exited $status"
	return $status
}

# Set an exit handler
#
# $@ - function(s) to perform on exit

function log_onexit
{
	_CLEANUP="$@"
}

#
# Exit functions
#

# Perform cleanup and exit $STF_PASS
#
# $@ - message text

function log_pass
{
	_endlog $STF_PASS "$@"
}

# Perform cleanup and exit $STF_FAIL
#
# $@ - message text

function log_fail
{
	_endlog $STF_FAIL "$@"
}

# Perform cleanup and exit $STF_UNRESOLVED
#
# $@ - message text

function log_unresolved
{
	_endlog $STF_UNRESOLVED "$@"
}

# Perform cleanup and exit $STF_NOTINUSE
#
# $@ - message text

function log_notinuse
{
	_endlog $STF_NOTINUSE "$@"
}

# Perform cleanup and exit $STF_UNSUPPORTED
#
# $@ - message text

function log_unsupported
{
	_endlog $STF_UNSUPPORTED "$@"
}

# Perform cleanup and exit $STF_UNTESTED
#
# $@ - message text

function log_untested
{
	_endlog $STF_UNTESTED "$@"
}

# Perform cleanup and exit $STF_UNINITIATED
#
# $@ - message text

function log_uninitiated
{
	_endlog $STF_UNINITIATED "$@"
}

# Perform cleanup and exit $STF_NORESULT
#
# $@ - message text

function log_noresult
{
	_endlog $STF_NORESULT "$@"
}

# Perform cleanup and exit $STF_WARNING
#
# $@ - message text

function log_warning
{
	_endlog $STF_WARNING "$@"
}

# Perform cleanup and exit $STF_TIMED_OUT
#
# $@ - message text

function log_timed_out
{
	_endlog $STF_TIMED_OUT "$@"
}

# Perform cleanup and exit $STF_OTHER
#
# $@ - message text

function log_other
{
	_endlog $STF_OTHER "$@"
}

#
# Internal functions
#

# Execute custom callback scripts on test failure
#
# callback script paths are stored in TESTFAIL_CALLBACKS, delimited by ':'.

function _execute_testfail_callbacks
{
	typeset callback

	print "$TESTFAIL_CALLBACKS:" | while read -d ":" callback; do
		if [[ -n "$callback" ]]; then
			log_note "Performing test-fail callback ($callback)"
			$callback
		fi
	done
}

# Perform cleanup and exit
#
# $1 - stf exit code
# $2-$n - message text

function _endlog
{
	typeset exitcode=$1
	shift
	typeset callback_output=$(mktemp)

	if $TR_STOP_ON_FAILURE; then
		if [[ $exitcode -ne $STF_PASS ]]; then
			log_note "Exiting without running callback or cleanup."
			exit $exitcode
		fi
	fi

	if [[ $exitcode -eq $STF_FAIL ]]; then
		_execute_testfail_callbacks >$callback_output 2>&1
	fi

	if [[ -n $_CLEANUP ]]; then
		typeset cleanup=$_CLEANUP
		log_onexit ""
		log_note "Performing local cleanup via log_onexit ($cleanup)"
		$cleanup
	fi

	(( ${#@} > 0 )) && echo "$@"

	[[ -s $callback_output ]] && cat $callback_output
	rm -f $callback_output

	exit $exitcode
}
