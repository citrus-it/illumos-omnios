#! /usr/bin/ksh -p
#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#

#
# Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#

. $STF_SUITE/tests/acl/acl_common.kshlib

#################################################################################
#
# __stc_assertion_start
#
# ID: acl_chmod_compact_pos001
#
# DESCRIPTION:
#	chmod A{+|-|=} could set compact ACL correctly.
#
# STRATEGY:
#	1. Loop root and non-root user.
#	2. Get the random compact ACL string.
#	4. Separately chmod +|-|=
#	5. Check compact ACL display as expected 
#
# TESTABILITY: explicit
#
# TEST_AUTOMATION_LEVEL: automated
#
# CODING_STATUS: COMPLETED (2006-08-11)
#
# __stc_assertion_end
#
################################################################################

[[ :$NFSGEN_DEBUG: = *:${NAME}:* || :${NFSGEN_DEBUG}: = *:all:* ]] \
	&& set -x

echo "ASSERTION: chmod A{+|=} should set compact ACL correctly."

set -A a_flag owner group everyone
set -A a_access r w x p d D a A R W c C o s 
set -A a_inherit_object f d
set -A a_inherit_strategy i n
set -A a_type allow deny

#
# Get a random item from an array.
#
# $1 the base set
#
function random_select #array_name
{
	[[ :$NFSGEN_DEBUG: = *:${NAME}:* || :${NFSGEN_DEBUG}: = *:all:* ]] \
		&& set -x

	typeset arr_name=$1
	typeset -i ind

	eval typeset -i cnt=\${#${arr_name}[@]}
	(( ind = $RANDOM % cnt ))

	eval print \${${arr_name}[$ind]}
}

#
# Create a random string according to array name, the item number and 
# separated tag.
#
# $1 array name where the function get the elements
# $2 the items number which you want to form the random string
# $3 the separated tag
#
function form_random_str #<array_name> <count> <sep>
{
	[[ :$NFSGEN_DEBUG: = *:${NAME}:* || :${NFSGEN_DEBUG}: = *:all:* ]] \
		&& set -x

	typeset arr_name=$1
	typeset -i count=${2:-1}
	typeset sep=${3:-""}

	typeset str=""
	while (( count > 0 )); do
		str="${str}$(random_select $arr_name)${sep}"

		(( count -= 1 ))
	done

	print $str
}

#
# Get the sub string from specified source string
#
# $1 source string
# $2 start position. Count from 1
# $3 offset
#
function get_substr #src_str pos offset
{
	[[ :$NFSGEN_DEBUG: = *:${NAME}:* || :${NFSGEN_DEBUG}: = *:all:* ]] \
		&& set -x

	typeset pos offset

	$ECHO $1 | \
		$NAWK -v pos=$2 -v offset=$3 '{print substr($0, pos, offset)}'
}

#
# According to the input ACE access,ACE type, and inherit flags, return the
# expect compact ACE that could be used by chmod A0{+|=}'.
#
# $1 ACE flag which is owner, group, or everyone
# $2 ACE access generated by the element of a_access
# $3 ACE inherit_object generated by the element of a_inherit_object
# $4 ACE inherit_strategy generated by the element of a_inherit_strategy
# $5 ACE type which is allow or deny
#
function cal_ace # acl_flag acl_access \
		 # acl_inherit_object acl_inherit_strategy acl_type
{
	[[ :$NFSGEN_DEBUG: = *:${NAME}:* || :${NFSGEN_DEBUG}: = *:all:* ]] \
		&& set -x

	typeset acl_flag=$1
	typeset acl_access=$2
	typeset acl_inherit_object=$3
	typeset acl_inherit_strategy=$4
	typeset acl_type=$5

	tmp_ace=${acl_flag}@:

	for element in ${a_access[@]} ; do
		if [[ $acl_access == *"$element"* ]]; then
			tmp_ace="${tmp_ace}${element}"
		else
			tmp_ace="${tmp_ace}-"
		fi
	done
	tmp_ace=${tmp_ace}:

	for element in ${a_inherit_object[@]} ; do
		if [[ $acl_inherit_object == *"$element"* ]]; then
			tmp_ace="${tmp_ace}${element}"
		else
			tmp_ace="${tmp_ace}-"
		fi
	done
	for element in ${a_inherit_strategy[@]} ; do
		if [[ $acl_inherit_strategy == *"$element"* ]]; then
			tmp_ace="${tmp_ace}${element}"
		else
			tmp_ace="${tmp_ace}-"
		fi
	done

	tmp_ace=${tmp_ace}---:${acl_type}
	
	echo "${tmp_ace}"
}

#
# Check if chmod set the compact ACE correctly.
#
function check_test_result # node acl_flag acl_access \
			   # acl_inherit_object acl_inherit_strategy acl_type
{
	[[ :$NFSGEN_DEBUG: = *:${NAME}:* || :${NFSGEN_DEBUG}: = *:all:* ]] \
		&& set -x

	typeset node=$1
	typeset acl_flag=$2
	typeset acl_access=$3
	typeset acl_inherit_object=$4
	typeset acl_inherit_strategy=$5
	typeset acl_type=$6

	typeset expect_ace=$(cal_ace "$acl_flag" "$acl_access" \
		"$acl_inherit_object" "$acl_inherit_strategy" "$acl_type")	

	typeset cur_ace=$(get_ACE $node 0 "compact")

	if [[ $cur_ace != $expect_ace ]]; then
		echo "FAIL: Current map($cur_ace) !=  \
			expected ace($expect_ace)"
		cleanup $STF_FAIL
	fi
}

function test_chmod_map #<node>
{
	[[ :$NFSGEN_DEBUG: = *:${NAME}:* || :${NFSGEN_DEBUG}: = *:all:* ]] \
		&& set -x

	typeset node=$1	
	typeset acl_flag acl_access acl_inherit_object acl_inherit_strategy acl_type
	typeset -i cnt

	if (( ${#node} == 0 )); then
		echo "FAIL: file name or directroy name is not defined."
		cleanup $STF_FAIL
	fi

        # Get ACL flag, access & type
	eval "acl_flag=$(form_random_str a_flag)"
	(( cnt = ($RANDOM % ${#a_access[@]}) + 1 ))
	eval "acl_access=$(form_random_str a_access $cnt)"
	acl_access=${acl_access%/}
	eval "acl_type=$(form_random_str a_type 1)"

	acl_spec=${acl_flag}@:${acl_access}
	if [[ -d $node ]]; then
		# Get ACL inherit_object & inherit_strategy
		(( cnt = ($RANDOM % ${#a_inherit_object[@]}) + 1 ))
		eval "acl_inherit_object=$(form_random_str a_inherit_object $cnt)"
		(( cnt = ($RANDOM % ${#a_inherit_strategy[@]}) + 1 ))
		eval "acl_inherit_strategy=$(form_random_str a_inherit_strategy $cnt)"
		acl_spec=${acl_spec}:${acl_inherit_object}${acl_inherit_strategy}
	fi
	acl_spec=${acl_spec}:${acl_type}

	# Set the initial map and back the initial ACEs
	typeset orig_ace=$STF_TMPDIR/orig_ace.$$
	typeset cur_ace=$STF_TMPDIR/cur_ace.$$

	for operator in "A0+" "A0="; do
		RUN_CHECK usr_exec eval "$LS -Vd $node > $orig_ace" \
			|| cleanup $STF_FAIL

		# To "A=", firstly add one ACE which can't modify map
		if [[ $operator == "A0=" ]]; then
			RUN_CHECK $CHMOD A0+user:$ACL_OTHER1:execute:deny \
				$node || cleanup $STF_FAIL
		fi
		RUN_CHECK usr_exec $CHMOD ${operator}${acl_spec} $node \
			|| cleanup $STF_FAIL
			
		check_test_result \
			"$node" "$acl_flag" "$acl_access" \
			"$acl_inherit_object" "$acl_inherit_strategy" \
			"$acl_type"

		# Check "chmod A-"
		RUN_CHECK usr_exec $CHMOD A0- $node || cleanup $STF_FAIL
		RUN_CHECK usr_exec eval "$LS -Vd $node > $cur_ace" \
			|| cleanup $STF_FAIL

		$DIFF $orig_ace $cur_ace
		[[ $? -ne 0 ]] && \
			echo "FAIL: 'chmod A-' failed." && \
			cleanup $STF_FAIL
	done

	[[ -f $orig_ace ]] && RUN_CHECK usr_exec $RM -f $orig_ace
	[[ -f $cur_ace ]] &&  RUN_CHECK usr_exec $RM -f $cur_ace
}

#for user in root $ACL_STAFF1; do
for user in $ACL_STAFF1; do
	set_cur_usr $user
	
	typeset -i loop_cnt=2
	while (( loop_cnt > 0 )); do
		RUN_CHECK usr_exec $TOUCH $testfile || cleanup $STF_FAIL
		test_chmod_map $testfile
		RUN_CHECK $RM -f $testfile || cleanup $STF_FAIL

		RUN_CHECK usr_exec $MKDIR $testdir || cleanup $STF_FAIL
		test_chmod_map $testdir
		RUN_CHECK $RM -rf $testdir || cleanup $STF_FAIL

		(( loop_cnt -= 1 ))
	done
done

# chmod A{+|=} set compact ACL correctly.
cleanup $STF_PASS
